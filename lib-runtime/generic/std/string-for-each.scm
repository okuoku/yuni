(define (string-for-each4/itr! pos len proc a b c d)
  (unless (= pos len)
    (proc (string-ref a pos)
          (string-ref b pos)
          (string-ref c pos)
          (string-ref d pos))
    (string-for-each4/itr! (+ pos 1) len proc a b c d)))

(define (string-for-each4 proc a b c d)
  (let ((len (min (string-length a) (string-length b)
                  (string-length c) (string-length d))))
    (string-for-each4/itr! 0 len proc a b c d)))

(define (string-for-each3/itr! pos len proc a b c)
  (unless (= pos len)
    (proc (string-ref a pos)
          (string-ref b pos)
          (string-ref c pos))
    (string-for-each3/itr! (+ pos 1) len proc a b c)))

(define (string-for-each3 proc a b c)
  (let ((len (min (string-length a) (string-length b) (string-length c))))
    (string-for-each3/itr! 0 len proc a b c)))

(define (string-for-each2/itr! pos len proc a b)
  (unless (= pos len)
    (proc (string-ref a pos)
          (string-ref b pos))
    (string-for-each2/itr! (+ pos 1) len proc a b)))

(define (string-for-each2 proc a b)
  (let ((len (min (string-length a) (string-length b))))
    (string-for-each2/itr! 0 len proc a b)))

(define (string-for-each1/itr! pos len proc a)
  (unless (= pos len)
    (proc (string-ref a pos))
    (string-for-each1/itr! (+ pos 1) len proc a)))

(define (string-for-each1 proc a)
  (let ((len (string-length a)))
    (string-for-each1/itr! 0 len proc a)))

(define (string-for-each proc a . args)
  (if (null? args)
    (string-for-each1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (string-for-each2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (string-for-each3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (string-for-each4 proc a b c d)
                (error "Too many...")))))))))
