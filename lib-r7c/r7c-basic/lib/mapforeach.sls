(library (r7c-basic lib mapforeach)
         (export map
                 string-map
                 vector-map
                 for-each
                 string-for-each
                 vector-for-each)
         (import (r7c-basic syntax define)
                 (r7c-system core)
                 (r7c core error)
                 (r7c syntax if)
                 (r7c syntax or)
                 (r7c syntax let)
                 (r7c syntax unless)
                 (r7c heap core)
                 (r7c heap vector)
                 (r7c heap fixnum)
                 (r7c heap pair))

;; FIXME: we have no map5 or more...

(define ($fxmin/itr a queue)
  (if (null? queue)
    a
    (let ((b (car queue)))
     ($fxmin/itr (if ($fx< a b) a b) (cdr queue)))))

(define ($fxmin a . queue)
  ($fxmin/itr a queue))

(define (vector-for-each4/itr pos len proc a b c d)
  (unless ($fx= pos len)
    (proc (vector-ref a pos) (vector-ref b pos)
          (vector-ref c pos) (vector-ref d pos))
    (vector-for-each4/itr ($fx+ pos 1) len proc a b c d)))

(define (vector-for-each4 proc a b c d)
  (vector-for-each4/itr 0 ($fxmin (vector-length a)
                                  (vector-length b)
                                  (vector-length c)
                                  (vector-length d))
                        proc a b c d))

(define (vector-for-each3/itr pos len proc a b c)
  (unless ($fx= pos len)
    (proc (vector-ref a pos) (vector-ref b pos) (vector-ref c pos))
    (vector-for-each3/itr ($fx+ pos 1) len proc a b c)))

(define (vector-for-each3 proc a b c)
  (vector-for-each3/itr 0 ($fxmin (vector-length a)
                                  (vector-length b)
                                  (vector-length c))
                        proc a b c))

(define (vector-for-each2/itr pos len proc a b)
  (unless ($fx= pos len)
    (proc (vector-ref a pos) (vector-ref b pos))
    (vector-for-each2/itr ($fx+ pos 1) len proc a b)))

(define (vector-for-each2 proc a b)
  (vector-for-each2/itr 0 ($fxmin (vector-length a)
                                  (vector-length b))
                        proc a b))

(define (vector-for-each1/itr pos len proc a)
  (unless ($fx= pos len)
    (proc (vector-ref a pos))
    (vector-for-each1/itr ($fx+ pos 1) len proc a)))

(define (vector-for-each1 proc a)
  (vector-for-each1/itr 0 (vector-length a) proc a))

(define (vector-for-each proc a . args)
  (if (null? args)
    (vector-for-each1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (vector-for-each2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (vector-for-each3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (vector-for-each4 proc a b c d)
                (error "Too many...")))))))))

(define (vector-map4/itr! v pos len proc a b c d)
  (unless ($fx= pos len)
    (vector-set! v pos
                 (proc (vector-ref a pos)
                       (vector-ref b pos)
                       (vector-ref c pos)
                       (vector-ref d pos)))
    (vector-map4/itr! v ($fx+ pos 1) len proc a b c d)))

(define (vector-map4 proc a b c d)
  (let* ((len ($fxmin (vector-length a) (vector-length b)
                      (vector-length c) (vector-length d)))
         (v ($make-vector len)))
    (vector-map4/itr! v 0 len proc a b c d)
    v))

(define (vector-map3/itr! v pos len proc a b c)
  (unless ($fx= pos len)
    (vector-set! v pos
                 (proc (vector-ref a pos)
                       (vector-ref b pos)
                       (vector-ref c pos)))
    (vector-map3/itr! v ($fx+ pos 1) len proc a b c)))

(define (vector-map3 proc a b c)
  (let* ((len ($fxmin (vector-length a) (vector-length b) (vector-length c)))
         (v ($make-vector len)))
    (vector-map3/itr! v 0 len proc a b c)
    v))

(define (vector-map2/itr! v pos len proc a b)
  (unless ($fx= pos len)
    (vector-set! v pos
                 (proc (vector-ref a pos)
                       (vector-ref b pos)))
    (vector-map2/itr! v ($fx+ pos 1) len proc a b)))

(define (vector-map2 proc a b)
  (let* ((len ($fxmin (vector-length a) (vector-length b)))
         (v ($make-vector len)))
    (vector-map2/itr! v 0 len proc a b)
    v)) 

(define (vector-map1/itr! v pos len proc a)
  (unless ($fx= pos len)
    (vector-set! v pos
                 (proc (vector-ref a pos)))
    (vector-map1/itr! v ($fx+ pos 1) len proc a)))

(define (vector-map1 proc a)
  (let* ((len (vector-length a))
         (v ($make-vector len)))
    (vector-map1/itr! v 0 len proc a)
    v))

(define (vector-map proc a . args)
  (if (null? args)
    (vector-map1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (vector-map2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (vector-map3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (vector-map4 proc a b c d)
                (error "Too many...")))))))))

(define (string-for-each4/itr pos len proc a b c d)
  (unless ($fx= pos len)
    (proc (string-ref a pos)
          (string-ref b pos)
          (string-ref c pos)
          (string-ref d pos))
    (string-for-each4/itr ($fx+ pos 1) len proc a b c d)))

(define (string-for-each4 proc a b c d)
  (string-for-each4/itr 0 ($fxmin (string-length a)
                                  (string-length b)
                                  (string-length c)
                                  (string-length d))
                        proc a b c d))

(define (string-for-each3/itr pos len proc a b c)
  (unless ($fx= pos len)
    (proc (string-ref a pos)
          (string-ref b pos)
          (string-ref c pos))
    (string-for-each3/itr ($fx+ pos 1) len proc a b c)))

(define (string-for-each3 proc a b c)
  (string-for-each3/itr 0 ($fxmin (string-length a)
                                  (string-length b)
                                  (string-length c))
                        proc a b c))

(define (string-for-each2/itr pos len proc a b)
  (unless ($fx= pos len)
    (proc (string-ref a pos)
          (string-ref b pos))
    (string-for-each2/itr ($fx+ pos 1) len proc a b)))

(define (string-for-each2 proc a b)
  (string-for-each2/itr 0 ($fxmin (string-length a)
                                  (string-length b))
                        proc a b))

(define (string-for-each1/itr pos len proc a)
  (unless ($fx= pos len)
    (proc (string-ref a pos))
    (string-for-each1/itr ($fx+ pos 1) len proc a))) 

(define (string-for-each1 proc a)
  (string-for-each1/itr 0 (string-length a) proc a))

(define (string-for-each proc a . args)
  (if (null? args)
    (string-for-each1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (string-for-each2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (string-for-each3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (string-for-each4 proc a b c d)
                (error "Too many...")))))))))

(define (string-map4/itr! s pos len proc a b c d)
  (unless ($fx= pos len)
    (string-set! s pos
                 (proc (string-ref a pos)
                       (string-ref b pos)
                       (string-ref c pos)
                       (string-ref d pos)))
    (string-map4/itr! s ($fx+ pos 1) len proc a b c d)))

(define (string-map4 proc a b c d)
  (let* ((len ($fxmin (string-length a) (string-length b)
                      (string-length c) (string-length d)))
         (s ($make-string len)))
    (string-map4/itr! s 0 len proc a b c d)
    s))

(define (string-map3/itr! s pos len proc a b c)
  (unless ($fx= pos len)
    (string-set! s pos
                 (proc (string-ref a pos)
                       (string-ref b pos)
                       (string-ref c pos)))
    (string-map3/itr! s ($fx+ pos 1) len proc a b c)))

(define (string-map3 proc a b c)
  (let* ((len ($fxmin (string-length a) (string-length b) (string-length c)))
         (s ($make-string len)))
    (string-map3/itr! s 0 len proc a b c)
    s))

(define (string-map2/itr! s pos len proc a b)
  (unless ($fx= pos len)
    (string-set! s pos
                 (proc (string-ref a pos)
                       (string-ref b pos)))
    (string-map2/itr! s ($fx+ pos 1) len proc a b)))

(define (string-map2 proc a b)
  (let* ((len ($fxmin (string-length a) (string-length b)))
         (s ($make-string len)))
    (string-map2/itr! s 0 len proc a b)
    s))

(define (string-map1/itr! s pos len proc a)
  (unless ($fx= pos len)
    (string-set! s pos (proc (string-ref a pos)))
    (string-map1/itr! s ($fx+ pos 1) len proc a))) 

(define (string-map1 proc a)
  (let* ((len (string-length a))
         (s ($make-string len)))
   (string-map1/itr! s 0 len proc a)
   s))

(define (string-map proc a . args)
  (if (null? args)
    (string-map1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (string-map2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (string-map3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (string-map4 proc a b c d)
                (error "Too many...")))))))))

(define (for-each4 proc a b c d)
  (unless (or (null? a) (null? b) (null? c) (null? d))
    (proc (car a) (car b) (car c) (car d))
    (for-each4 proc (cdr a) (cdr b) (cdr c) (cdr d))))

(define (for-each3 proc a b c)
  (unless (or (null? a) (null? b) (null? c))
    (proc (car a) (car b) (car c))
    (for-each3 proc (cdr a) (cdr b) (cdr c))))

(define (for-each2 proc a b)
  (unless (or (null? a) (null? b))
    (proc (car a) (car b))
    (for-each2 proc (cdr a) (cdr b))))

(define (for-each1 proc a)
  (unless (null? a)
    (proc (car a))
    (for-each1 proc (cdr a)))) 

(define (for-each proc a . args)
  (if (null? args)
    (for-each1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (for-each2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (for-each3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (for-each4 proc a b c d)
                (error "Too many...")))))))))

(define (map4/itr! cur proc a b c d)
  (unless (or (null? a) (null? b) (null? c) (null? d))
    (let ((p (cons (proc (car a) (car b) (car c) (car d)) '())))
     (set-cdr! cur p)
     (map4/itr! p proc (cdr a) (cdr b) (cdr c) (cdr d)))))

(define (map4 proc a b c d)
  (if (or (null? a) (null? b) (null? c) (null? d))
    '()
    (let ((p (cons (proc (car a) (car b) (car c) (car d)) '())))
     (map4/itr! p proc (cdr a) (cdr b) (cdr c) (cdr d))
     p)))

(define (map3/itr! cur proc a b c)
  (unless (or (null? a) (null? b) (null? c))
    (let ((p (cons (proc (car a) (car b) (car c)) '())))
     (set-cdr! cur p)
     (map3/itr! p proc (cdr a) (cdr b) (cdr c)))))
         
(define (map3 proc a b c)
  (if (or (null? a) (null? b) (null? c))
    '()
    (let ((p (cons (proc (car a) (car b) (car c)) '())))
     (map3/itr! p proc (cdr a) (cdr b) (cdr c))
     p)))

(define (map2/itr! cur proc a b)
  (unless (or (null? a) (null? b))
    (let ((c (cons (proc (car a) (car b)) '())))
     (set-cdr! cur c)
     (map2/itr! c proc (cdr a) (cdr b)))))

(define (map2 proc a b)
  (if (or (null? a) (null? b))
    '()
    (let ((c (cons (proc (car a) (car b)) '())))
     (map2/itr! c proc (cdr a) (cdr b))
     c)))

(define (map1/itr! cur proc a)
  (unless (null? a)
    (let ((c (cons (proc (car a)) '())))
     (set-cdr! cur c)
     (map1/itr! c proc (cdr a)))))

(define (map1 proc a)
  (if (null? a)
    '()
    (let ((c (cons (proc (car a)) '())))
     (map1/itr! c proc (cdr a)) 
     c)))

(define (map proc a . args)
  (if (null? args)
    (map1 proc a)
    (let ((b (car args))
          (bb (cdr args)))
      (if (null? bb)
        (map2 proc a b)
        (let ((c (car bb))
              (cc (cdr bb)))
          (if (null? cc)
            (map3 proc a b c)
            (let ((d (car cc))
                  (dd (cdr cc)))
              (if (null? dd)
                (map4 proc a b c d)
                (error "Too many...")))))))))         
         
)
